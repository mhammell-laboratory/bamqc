#!/usr/bin/env python
'''manipulate BAM/SAM file.'''

#import built-in modules
import os,sys
import re
import string
from optparse import OptionParser
import warnings
import string
import collections
import math
import sets
import random

#import third-party modules
from bx.bitset import *
from bx.bitset_builders import *
from bx.intervals import *
from bx.binned_array import BinnedArray
from bx_extras.fpconst import isNaN
from bx.bitset_utils import *
import pysam

from libBAMQC.Results import *
from libBAMQC.Config import *
from libBAMQC.Mappability import *
from libBAMQC.Coverage_prof import *
from libBAMQC.InerDist_prof import *
from libBAMQC.ReadDup_prof import *


def fetch_intron( st, cigar,format):
    ''' fetch intron regions defined by cigar. st must be zero based
        return list of tuple of (chrom,st, end)
        '''
    #match = re.compile(r'(\d+)(\D)')
    chrom_st = st
    if format == "BAM" :
        chrom_st += 1
    
    intron_bound =[]
    for c,s in cigar:	#code and size
        if c==0:		#match
            chrom_st += s
        elif c==1:		#insertion to ref
            continue
        elif c==2:		#deletion to ref
            chrom_st += s
        elif c==3:		#gap or intron
            intron_bound.append((chrom_st,chrom_st+s))
            chrom_st += s
        elif c==4:		#soft clipping. We do NOT include soft clip as part of exon
            chrom_st += s
        else:
            continue
        return intron_bound


def fetch_exon(chrom, st, cigar,direction,format):
    ''' fetch exon regions defined by cigar. st must be zero based
        return list of tuple of (chrom,st, end)
        '''
    #match = re.compile(r'(\d+)(\D)')
    chrom_st = st
    if format == "BAM" :
        chrom_st += 1
    exon_bound =[]

    for c,s in cigar:    #code and size
        if c==0:        #match
            exon_bound.append([chrom, chrom_st,chrom_st + s-1,direction])

            chrom_st += s

        elif c==1:        #insertion to ref
            continue
        elif c==2:        #deletion to ref
            chrom_st += s
        elif c==3:        #gap or intron
            chrom_st += s
        elif c==4:        #soft clipping. We do NOT include soft clip as part of exon
            chrom_st += s
        else:
            continue
    return exon_bound


# parsing BAM file
class ParseBAM:
	'''This class provides fuctions to parsing SAM or BAM files and quality controls.'''
	
	def __init__(self,inputFile,stranded):
		'''constructor. input could be bam or sam'''
        self.stranded = stranded
		try:
			self.samfile = pysam.AlignmentFile(inputFile,'rb')
			if len(self.samfile.header) ==0:
				print >>sys.stderr, "BAM/SAM file has no header section. Exit!"
				sys.exit(1)
			self.format = "BAM"
		except:
			self.samfile = pysam.AlignmentFile(inputFile,'r')
			if len(self.samfile.header) ==0:
				print >>sys.stderr, "BAM/SAM file has no header section. Exit!"
				sys.exit(1)
            self.format = "SAM"

    def qc (self,rRNAidx,geneIdx,mapq,outfile_fig,outfile) :

        q_cut = mapq
        
		res = Results()
		'''Calculate mapping statistics'''
        rrNA_read = 0
		intron_read = 0
		cds_exon_read = 0
		utr_5_read = 0
		utr_3_read = 0	
		intergenic_up1kb_read = 0
		intergenic_down1kb_read = 0
		unAssignFrags = 0
		intergenic_read = 0 
		
		prev_read_id = ""
		multi_read_flag = 0
		first_read_flag = 0
		second_read_flag = 0
        #multi_reads = []
		multi_read1 = []
		multi_read2 = []
        alignments_per_read = []
		
		clip_prof = Clipping_prof(outfile,outfile_fig)
		cov_prof = CoverageBody_prof(outfile,outfile_fig,geneIdx)
		rDup_prof = ReadDup_prof(outfile,outfile_fig)
		inDist_prof = InnerDist_prof(outfile,outfile_fig)
		
		try:
			while(1):
                #read in one alignment
				aligned_read = self.samfile.next()
				cur_reads = []
                
                #SE reads
				if not aligned_read.is_paired :					
					#count unmapped read
					if aligned_read.is_unmapped :
						res.unmapped_reads += 1
						res.total_reads += 1
						continue
									
					if aligned_read.qname == prev_read_id :
						alignments_per_read.append((aligned_read,None))
						continue
					else :				
						cur_read = None		
                        if len(alignments_per_read) == 1 : #unique read
                            res.uniq_mapped_reads += 1
                            res.total_reads += 1
                                
							cur_read = alignments_per_read[0][0]
                            
							skip_read  = 0
							if cur_read.is_qcfail or cur_read.mapq < q_cut:	#skip QC fail read
								res.low_qual += 1
								skip_read = 1
							if cur_read.is_duplicate:		#skip duplicate read
								skip_read = 1
							if skip_read == 1 :
								cur_read = None
							
                        if len(alignments_per_read) > 1: #multi reads
							res.multi_mapped_reads += 1
							res.total_reads += 1
							cur_read = None
						
						if cur_read is not None :
							cur_reads.append((cur_read,None))
							if cur_read.is_reverse:
								res.reverse_read += 1
							else:
								res.forward_read += 1	
								
                        if len(alignments_per_read) > 1:
                            cur_reads.extend(alignments_per_read)
                                
						alignments_per_read = []
						alignments_per_read.append((aligned_read,None))
						prev_read_id = aligned_read.qname
						
				#pair end read
				if aligned_read.is_paired :
					res.is_pairEnd = True					
					if aligned_read.qname == prev_read_id :
						if aligned_read.is_read1 :
							multi_read1.append(aligned_read)
						if aligned_read.is_read2 :
							multi_read2.append(aligned_read)						
					else :
						cur_read1 = None
						cur_read2 = None
                        
						#uniq read
						if len(multi_read1) == 1 or len(multi_read2) == 1 :
                            res.uniq_mapped_reads += 1
                            res.total_reads += 1
                                    
							if len(multi_read1) == 1:
								cur_read1 = multi_read1[0]
							if len(multi_read2) == 1:
								cur_read2 = multi_read2[0]
                            
							#unmapped read and low quality read
							if (cur_read1 is None or cur_read1.is_unmapped) and (cur_read2 is None or cur_read2.is_unmapped) :
								res.unmapped_reads += 1
								
							if cur_read1 is None or cur_read1.is_unmapped :
								res.unmapped_read1 += 1
								cur_read1 = None
                        
                            if cur_read2 is None or cur_read2.is_unmapped :
                                res.unmapped_read2 += 1
                                cur_read2 = None
                                                
                            if cur_read1 is not None :
								res.mapped_read1 += 1
								if cur_read1.is_reverse :
									res.reverse_read += 1
								else :
									res.forward_read += 1
								if cur_read1.is_qcfail or cur_read1.mapq < q_cut:
                                    #res.low_qual += 1
									cur_read1 = None
                            
                            if cur_read2 is not None :
								res.mapped_read2 += 1
								if cur_read2.is_reverse :
									res.reverse_read += 1
								else :
									res.forward_read += 1
								if cur_read2.is_qcfail or cur_read2.mapq < q_cut:
                                    #res.low_qual += 1
									cur_read2 = None
                                        
                            if cur_read1 is None and cur_read2 is None :
                                res.low_qual += 1
                            

							#not properly paired read
                            if cur_read1 is not None and not cur_read1.is_proper_pair :
                                res.paired_diff_chrom += 1
                                if cur_read1.is_reverse and cur_read1.mate_is_reverse :
                                    res.mapped_minus_minus  += 1
                                if not cur_read1.is_reverse and not cur_read1.mate_is_reverse :
                                    res.mapped_plus_plus += 1
                                        
                            #properly paired read
							if cur_read1 is not None and cur_read1.is_proper_pair :
								res.paired_reads += 1
								R_read1_ref = self.samfile.getrname(cur_read1.tid)
                                strand = "+"
                                
                                if not cur_read1.is_reverse and cur_read1.mate_is_reverse :
                                    res.mapped_plus_minus += 1
                                
                                if cur_read1.is_reverse and not cur_read1.mate_is_reverse :
                                    res.mapped_minus_plus += 1
                                    strand = "-"
                                
                                #estimate insertion size ------need to finish
                                intron_blocks = []
                                if self.stranded == "reverse" :
                                    strand = "+" if strand == "-" else "-"

                                if strand == "+":
                                    intron_blocks = fetch_intron(cur_read1.pos,cur_read1.cigar,self.format)
                                else :
                                    intron_blocks = fetch_intron(cur_read2.pos,cur_read2.cigar,self.format)
                                if self.stranded == "no" :
                                    strand = "."
                                    
                                    exon_blocks = fetch_exon()
                                inDist_prof.count(geneIdx,gene,cur_read1,R_read1_ref.upper(),intron_blocks,strand)

                                #-----------------------
                                
							if cur_read1 is not None and cur_read2 is not None:
								cur_reads.append((cur_read1,cur_read2))
							
								
						#multi-reads		
						if len(multi_read1) >1 or len(multi_read2) > 1 :
							
							res.multi_mapped_reads += 1
							res.total_reads += 1
							if len(multi_read1) > 1:
								res.mapped_read1 += 1
							if len(multi_read2) > 1 :
								res.mapped_read2 += 1						
							
						multi_read1 = []
						multi_read2 = []
						prev_read_id = aligned_read.qname
						if aligned_read.is_read1 :
							multi_read1.append(aligned_read)
						if aligned_read.is_read2 :
							multi_read2.append(aligned_read)
				
				if len(cur_reads) == 2 and res.is_pairEnd == True: #properly paired 
					cur_read = cur_reads[0]
					cur_read_mate = cur_reads[1]
                    if self.stranded =="yes" and cur_read.is_reverse or self.stranded == "reverse" and not cur_read.is_reverse:
                        strand1 = "-"
                    else :
                        strand1 = "+"

                    if self.stranded == "no" :
                        strand1 = "."
                            
                        
					chrom1 = self.samfile.getrname(cur_read.tid)
					chrom1 = chrom1.upper()
					exons = fetch_exon(chrom1, cur_read.pos, cur_read.cigar,strand1,self.format)
					
                    if cur_read_mate.is_reverse and self.stranded == "yes" or self.stranded == "reverse" and not cur_read_mate.is_reverse::
                        strand2 = "-"
                    else :
                        strand2 = "+"
                     
                    if self.stranded == "no" :
                         strand2 = "."
					chrom2 = self.samfile.getrname(cur_read_mate.tid)
					chrom2 = chrom2.upper()
					exons2 = fetch_exon(chrom2, cur_read_mate.pos, cur_read_mate.cigar,strand2,self.format)
					#calculate gene coverage				
					cov_prof.count(geneIdx,exons,exons2,chrom1,chrom2)
					
				if len(cur_reads) == 1 : #either SE read or only one part is mapped of a PE
					cur_read = cur_reads[0]
                    if cur_read.is_reverse and self.stranded == "yes" or self.stranded == "reverse" and not cur_read.is_reverse :
                        
                        strand = "-"
                    else :
                        strand = "+"

                    if self.stranded == "no" :
                        strand2 = "."
                                    
					chrom = self.samfile.getrname(cur_read.tid)
					chrom = chrom.upper()
					exons = fetch_exon(chrom, cur_read.pos, cur_read.cigar,strand,self.format)
					#calculate gene coverage					
					cov_prof.count(geneIdx,exons)
												
				for (cur_read1,cur_read2) in cur_reads :
                    RNA_read1 = ""
                    RNA_read2 = ""
                    if cur_read1 is not None :
                        RNA_read1 = cur_read1.seq.upper()
                        clip_prof.set(cur_read1.cigarstring)
                    if cur_read2 is not None :
                        RNA_read2 = cur_read2.seq.upper()
                        clip_prof.set(cur_read2.cigarstring)
        
					##########			
					chrom = self.samfile.getrname(cur_read1.tid)
					chrom = chrom.upper()
                    if cur_read1.is_reverse and self.stranded == "yes" or self.stranded == "reverse" and not cur_read1.is_reverse :
    
                        strand = "-"
                    else :
                        strand = "+"
                
                    if self.stranded == "no" :
                        strand = "."
                    
                    exons1 = fetch_exon(chrom, cur_read1.pos, cur_read1.cigar,strand,self.format)

                    if cur_read2.is_reverse and self.stranded == "yes" or self.stranded == "reverse" and not cur_read2.is_reverse :
    
                        strand = "-"
                    else :
                        strand = "+"
                
                    if self.stranded == "no" :
                        strand = "."
                    
                    chrom = self.samfile.getrname(cur_read2.tid)
                    chrom = chrom.upper()
                    
                    exons2 = fetch_exon(chrom, cur_read2.pos, cur_read2.cigar,strand,self.format)
					#--------------				
					#read duplicate rate
					
					rDup_prof.count(RNA_read1,RNA_read2,exons1,exons2)
					
					#---------------
                    
                    if rRNAidx.is_rRNA(exons1) or rRNAidx.is_rRNA(exons2):
                        rrNA_read += 1
                        continue
                            
					for exn in exons:
						mid = int(exn[1]) + int((int(exn[2]) - int(exn[1])) / 2)
						if geneIdx.ovp_cds_exon(chrom, mid, mid) :
								cds_exon_read += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_utr5(chrom, mid, mid) and not geneIdx.ovp_utr3(chrom, mid, mid) :
								utr_5_read += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_utr3(chrom, mid, mid)  and not geneIdx.ovp_utr5(chrom, mid, mid) :
								utr_3_read += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_utr3(chrom, mid, mid) and geneIdx.ovp_utr5(chrom, mid, mid) :
								unAssignFrags += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_intron(chrom,  mid, mid) :
								intron_read += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_intergenicUp(chrom, mid, mid) :
								intergenic_up1kb_read += 1.0/len(cur_reads)
								continue
						elif geneIdx.ovp_intergenicDown(chrom, mid, mid) :
								intergenic_down1kb_read += 1.0/len(cur_reads)
								continue
						else:
							intergenic_read += 1.0/len(cur_reads)			
					
					introns = fetch_intron(cur_read.pos, cur_read.cigar,self.format)
                    
					if len(introns) == 0:
						res.noSplice += 1.0/len(cur_reads)
					if len(introns) >= 1:
						res.splice += 1.0/len(cur_reads)
								
		except StopIteration:
			pass
		
		res.splice = int(res.splice)
		res.noSplice = int(res.noSplice)
		
		prom_read = intergenic_up1kb_read  + intergenic_down1kb_read		  
		res.read_dist_plot_file = outfile_fig + ".read_distr.png"	
		  
		try :
			ROUT = open(outfile + '.read_distr.r', 'w')
			print >> ROUT, 'png("' + outfile_fig + '.read_distr.png",width=400,height=800,units="px")\n'
            print >> ROUT, 'par(mfrow=c(1,2)\n'
			print >> ROUT, 'M=c(" + str(cds_exon_read) + "," + str(utr_5_read) + "," + str(utr_3_read) + "," + str(intron_read) + "," + str(prom_read) + "," + str(rRNA_read) + "," + str(intergenic_read) + ")\n'
			
			print >> ROUT, 'Mname=c("CDS","5UTR","3UTR","Intron","Up/Down_1Kb","rRNA","Others")\n'
			print >> ROUT, 'val = barplot(M,xlab="",space=1,ylab="Read Counts")\n'
			print >> ROUT, 'text(x=seq(val[1],val[7],by=2),y=rep(0,7),srt=60,adj=0,offset=2,pos=1,xpd=T,labels=Mname)\n'
            
            print >> ROUT, 'pie(M,labels=Mname,radius=0.7,clockwise=T,col=c("#AFF8DB","#DBFFD6","#DBFFD6","#E7FFAC","#ACE7FF","#FFCBC1","white"))'
			print >> ROUT, "dev.state = dev.off()"
			
			ROUT.close()
		except :
			sys.stderr.write("Error in writing plotting scripts.\n")
			pass
		
		clip_prof.write(res.total_reads)
		rDup_prof.write()
		inDist_prof.write()
		cov_prof.write(res.total_reads)
		
		res.insert_plot_file = inDist_prof.plot_file
		res.clipping_plot_file = clip_prof.plot_file
		res.read_dup_plot_file = rDup_prof.plot_file
		res.read_cov_plot_file = cov_prof.plot_file
		res.geneCount_file = cov_prof.outfile3
		
		return res



		

